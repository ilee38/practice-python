#!/usr/bin/env python3

""" The sequence of triangle numbers is generated by adding the natural numbers.
    So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
    ten terms would be:
            1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:

    1: 1
    3: 1,3
    6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred divisors?
"""


def get_primes(n):
  """ Generates prime numbers, up to limit n.
      It implements the Sieve of Erathostenes, and it uses a bytearray.
      It also puts all prime numbers inside primes_list.
  """
  primes_list = []
  primes = bytearray([1]*n)
  for i in range(2, n):
    if primes[i] == 1:
      for j in range(i, n):
        if i*j < n:
          primes[i*j] = 0
        else:
          primes_list.append(i)
          break
  return primes_list


def get_prime_factors(tri_num, PRIMES_LIST):
  """ Generates the prime factors of a number (param tri_num)
  """
  factors = []
  while tri_num > 1:
    for i in range(len(PRIMES_LIST)):
      if tri_num % PRIMES_LIST[i] == 0:
        factors.append(PRIMES_LIST[i])
        tri_num /= PRIMES_LIST[i]
        break
  return factors


def get_all_factors(prime_factors):
  """ Note: this function was not used for this problem.
      The idea was to generate ALL factors (both prime and non-prime), based
      on the prime factors list
  """
  factor = 0
  all_factors = []
  for i in range(len(prime_factors)-1):
    for j in range(i+1, len(prime_factors)):
      all_factors.append(prime_factors[i] * prime_factors[j])
    factor = prime_factors[i]
    for k in range(i+1, len(prime_factors)):
      factor *= prime_factors[k]
      all_factors.append(factor)
  factors = set(all_factors) | set(prime_factors)
  factors.add(1)  #1 is always a factor
  return factors


def hi_divisible_tnum(divisors, PRIMES_LIST):
  """ Returns the first Triangular Number that has over n (param divisors)
      divisors.
  """
  tri_num = 0
  i = 1
  div_count = 0
  while div_count <= divisors:
    tri_num += i
    prime_factors = get_prime_factors(tri_num, PRIMES_LIST)
    #all_factors = get_all_factors(prime_factors)
    div_count = get_factor_count(prime_factors)
    i += 1
  return tri_num


def get_factor_count(prime_factors):
  """ Returns the total number of factors of a number, based on the prime factors
      of said number. This is accomplished using the formula:
          (e1 + 1)*(e2 + 1)*(e3 + 1)* ... *(en + 1)
      where e's are the exponents of the unique primes (recall the fundamental
      theorem of arithmetic).

      This process can be improved by generating a dictionary (hash table) containing
      the frequency of each prime, while generating the prime factors of the number
      (in the get_prime_factors() function above).
  """
  count = 1
  exp = 0
  unique_primes = set(prime_factors)
  for p in unique_primes:
    for i in range(len(prime_factors)):
      if p == prime_factors[i]:
        exp += 1
    count *= (exp + 1)
    exp = 0
  return count


def main():
  """ The general steps of the process are as follow:
        1. Generate a list of primes (big enough to contain all primes needed for
            prime factorization)
        2. Start generating triangular numbers and
        3. Get the prime factors of the triangular number
        4. Count the total factors (i.e. divisors) of the number. This can be
            done quickly using the formula (see the function get_factor_count())
        5. Return the first triangular factors that has more divisors over the
            given limit.

      After trial and error: 15,000 is (aprox.) the minimum limit for the prime
      list. If the list is less than that, it will not contain enough primes to
      generate the prime factors list.
  """
  PRIMES_LIST = get_primes(15000)
  print(hi_divisible_tnum(500, PRIMES_LIST))


if __name__ == "__main__":
    main()